#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@author:maojingxin
"""
import json
import math

import rsa
import rsa.common

__all__ = ["newkey", "toPubkey", "rsaEncrypt", "rsaDecrypt"]


def newkey(nbits: int):
    pubkey, privkey = rsa.newkeys(nbits)
    return pubkey, privkey


def toPubkey(n: int, e: int):
    return rsa.PublicKey(n, e)


def rsaEncrypt(pubkey, data, dumps=True):
    """
    rsaEncrypt data
    :param pubkey: a public-key generated by rsa
    :param data: the data will encrypt
    :param dumps: default is True , whether data need to serialize before encrypt
    :return:
    """
    if dumps:
        data = json.dumps(data)
    data = data.encode("utf-8")
    data_len = len(data)
    key_len = rsa.common.byte_size(pubkey.n)
    max_msg_len = key_len - 11
    if data_len > max_msg_len:
        chunk_len = int(math.ceil(data_len / max_msg_len))
        res_data = b""
        for i in range(chunk_len):
            start = max_msg_len * i
            chunk_data = data[start:start + max_msg_len]
            chunk_data = rsa.encrypt(chunk_data, pubkey)
            res_data += chunk_data
    else:
        res_data = rsa.encrypt(data, pubkey)
    return res_data


def rsaDecrypt(privkey, data, loads=True):
    """
    rsaDecrypt data
    :param privkey: a private-key generated by rsa
    :param data: the data will decrypt
    :param loads: default is True , whether decrypt data need to deserialize
    :return:
    """
    data_len = len(data)
    key_len = rsa.common.byte_size(privkey.n)
    if data_len > key_len:
        res_data = b""
        chunk_len = int(math.ceil(data_len / key_len))
        for i in range(chunk_len):
            start = key_len * i
            chunk_data = data[start:start + key_len]
            chunk_data = rsa.decrypt(chunk_data, privkey)
            res_data += chunk_data
    else:
        res_data = rsa.decrypt(data, privkey)
    res_data = res_data.decode("utf-8")
    if loads:
        res_data = json.loads(res_data)
    return res_data
